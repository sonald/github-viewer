/*jshint node:true*/

'use strict';

var util = require('util');

var Stream = require('stream');

var GithubApi = require('github');
var github = new GithubApi({
    version: '3.0.0'
});

var debug = (function() {
    if (process.env.DEBUG) {
        return function() {
            var util = require('util');

            var msg = [].slice.apply(arguments).reduce(function(acc, item) {
                item = typeof item === 'string'? item: util.inspect(item, true, 5);
                return acc + ' ' + item;
            });

            console.log(msg);
        };
    } else {
        return function() {};
    }
}());

function _endsWith(haystack, needle) {
    var idx = haystack.indexOf(needle);
    return idx > -1 && idx + needle.length === haystack.length;
}

var dataApi = github.getGitdataApi();

function Stub(url, sha) {
    this.url = url;
    this.sha = sha;
}

function Commit(repo, proto) {
    for (var prop in proto) {
        this[prop] = proto[prop];
    }

    this.repo = repo;

    if (this.parents) {
        this._parents = this.parents.map(function(par) {
            return new Stub(par.url, par.sha);
        });

        delete this.parents;
    }
}

Commit.prototype.getParents = function(done) {
    var self = this;

    if (!this._parents) {
        done(null, []);
        return;
    }

    var _pars = this._parents;
    var len = _pars.length;
    var count = len;

    function retrieveParent(i) {
        self.repo.getCommit(_pars[i].sha, function(err, commit) {
            if (!err) {
                _pars[i] = commit;
                count--;
                if (count === 0) {
                    done(null, self._parents);
                }

            } else {
                done(err, null);
            }
        });
    }

    for (var i = 0; i < len; i++) {
        if (_pars[i] instanceof Stub) {
            retrieveParent(i);
        }
    }
};

function Repo(user, name) {
    this.user = user;
    this.name = name;

    this._branch = null;
    this._refs = null;
}

module.exports.Repo = Repo;
module.exports.Commit = Commit;

Repo.prototype.updateRefsCache = function(callback) {
    var self = this;

    if (this._refs) {
        callback(null);
        return;
    }

    dataApi.getAllReferences({
        user: self.user,
        repo: self.name
    }, function(err, data) {
        // debug(data);
        self._refs = data;
        callback(err);
    });
};

Repo.prototype.showRefs = function(callback) {
    var self = this;

    if (!this._refs) {
        this.updateRefsCache(function(err) {
            callback(err, self._refs);
        });

    } else {
        callback(null, this._refs);
    }
};

Repo.prototype.currentBranch = function() {
    return this._branch;
};

Repo.prototype.changeBranch = function(ref, callback) {
    var self = this;

    function _findRef() {
        var refs = self._refs;
        var len = refs.length;

        for (var i = 0; i < len; i++) {
            if (_endsWith(refs[i].ref, ref)) {
                self._branch = refs[i];
                callback(null);
                return;
            }
        }

        callback('invalid reference: ' + ref);
    }

    if (!this._refs) {
        this.updateRefsCache(function(err) {
            if (err) {
                callback(err);
            } else {
                _findRef();
            }
        });

    } else {
        _findRef();
    }
};

Repo.prototype.log = function(options, callback) {
    var opts = options || {
        limit: 50,
        topology: true
    };
};

Repo.prototype.getCommit = function(sha, callback) {
    var self = this;

    dataApi.getCommit({
        'user': this.user,
        'repo': this.name,
        'sha': sha
    }, function(err, data) {
        // debug('data: ', Object.keys(data));
        var commit = new Commit(self, data);
        callback(err, commit);
    });
};

Repo.prototype.createCommitStream = function() {
    var self = this;

    var stream = new Stream();
    stream.readable = true;
    stream.writable = false;

    if (!this._branch)
        return;

    var branch = this._branch;
    function _getCommit(sha, callback) {
        self.getCommit(sha, function(err, commit) {
            stream.emit('data', commit);

            commit.getParents(function(err, parents) {
                if (parents && parents.length) {
                    parents.forEach(function(par) {
                        _getCommit(par.sha);
                    });

                } else {
                    stream.emit('end');
                }
            });
        });
    }

    _getCommit(branch.object.sha);
    return stream;
};

Repo.prototype.getTree = function(sha, recursive, callback) {
    var self = this;

    if (typeof recursive === 'function') {
        callback = recursive;
        recursive = false;
    }

    dataApi.getTree({
        'user': self.user,
        'repo': self.name,
        'sha': sha,
        'recursive': recursive
    }, function(err, data) {
        // debug(data);
        callback(err, data);
    });
};

// return a snapshot (project tree ) of a commit
Repo.prototype.getSnapshot = function(commit, recursive, callback) {
    this.getTree(commit.tree.sha, recursive, callback);
};


Repo.prototype.getBlob = function(sha, callback) {
    var self = this;

    dataApi.getBlob({
        'user': self.user,
        'repo': self.name,
        'sha': sha
    }, function(err, blob) {
        // debug(blob);
        callback(err, blob);
    });
};
