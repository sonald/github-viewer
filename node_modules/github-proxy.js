/*jshint node:true*/

'use strict';

var util = require('util');

var Stream = require('stream');

var GithubApi = require('github');
var github = new GithubApi({
    version: '3.0.0'
});

var debug = (function() {
    if (process.env.DEBUG) {
        return function() {
            var util = require('util');

            var msg = [].slice.apply(arguments).reduce(function(acc, item) {
                item = typeof item === 'string'? item: util.inspect(item, true, 5);
                return acc + ' ' + item;
            });

            console.log(msg);
        };
    } else {
        return function() {};
    }
}());

function _endsWith(haystack, needle) {
    var idx = haystack.indexOf(needle);
    return idx > -1 && idx + needle.length === haystack.length;
}

var dataApi = github.getGitdataApi();

function Stub(url, sha) {
    this.url = url;
    this.sha = sha;
}

function Commit(repo, proto) {
    for (var prop in proto) {
        this[prop] = proto[prop];
    }

    this.repo = repo;

    if (this.parents) {
        this._parents = this.parents.map(function(par) {
            return new Stub(par.url, par.sha);
        });

        delete this.parents;
    }
}

Commit.prototype.getParents = function(done) {
    var self = this;

    if (!this._parents || this._parents.length === 0) {
        debug('getParents: no parent');
        done(null, []);
        return;
    }

    var _pars = this._parents;
    var len = _pars.length;
    var count = len;
    debug('getParents: ', _pars);

    function retrieveParent(i) {
        if (!(_pars[i] instanceof Stub)) {
            count--;
            if (count === 0) {
                done(null, self._parents);
            }
            return;
        }

        self.repo.getCommit(_pars[i].sha, function(err, commit) {
            if (!err) {
                _pars[i] = commit;
                count--;
                if (count === 0) {
                    done(null, self._parents);
                }

            } else {
                done(err, null);
            }
        });
    }

    for (var i = 0; i < len; i++) {
        retrieveParent(i);
    }
};

function Repo(user, name) {
    this.user = user;
    this.name = name;

    this._branch = null;
    this._refs = null;

    this._commits = {}; // cache retrieved commits
}

module.exports.Repo = Repo;
module.exports.Commit = Commit;

Repo.prototype.updateRefsCache = function(callback) {
    var self = this;

    if (this._refs) {
        callback(null);
        return;
    }

    dataApi.getAllReferences({
        user: self.user,
        repo: self.name
    }, function(err, data) {
        // debug(data);
        self._refs = data;
        callback(err);
    });
};

Repo.prototype.showRefs = function(filter, callback) {
    var self = this;
    var fn = null;

    if (arguments.length === 2) {
        if (typeof fn !== 'function') {
            fn = function(ref) { return ref.ref.indexOf(filter) > -1; };
        }
    } else {
        callback = filter;
    }

    function _filterRefs() {
        var refs = fn ? self._refs.filter(fn) : self._refs;
        callback(null, refs);
    }

    if (!this._refs) {
        this.updateRefsCache(function(err) {
            if (err) {
                callback(err);
                return;
            }
            _filterRefs();
        });

    } else {
        _filterRefs();
    }
};

Repo.prototype.currentBranch = function() {
    return this._branch;
};

Repo.prototype.changeBranch = function(ref, callback) {
    var self = this;

    function _findRef() {
        var refs = self._refs;
        var len = refs.length;

        for (var i = 0; i < len; i++) {
            if (_endsWith(refs[i].ref, ref)) {
                self._branch = refs[i];
                callback(null);
                return;
            }
        }

        callback('invalid reference: ' + ref);
    }

    if (!this._refs) {
        this.updateRefsCache(function(err) {
            if (err) {
                callback(err);
            } else {
                _findRef();
            }
        });

    } else {
        _findRef();
    }
};

Repo.prototype.log = function(options, callback) {
    var opts = options || {
        limit: 50,
        topology: true
    };
};

Repo.prototype.getCommit = function(sha, callback) {
    var self = this;

    if (sha in this._commits) {
        callback(null, this._commits[sha]);
        return;
    }

    dataApi.getCommit({
        'user': this.user,
        'repo': this.name,
        'sha': sha
    }, function(err, data) {
        // debug('data: ', Object.keys(data));
        var commit = new Commit(self, data);
        self._commits[sha] = commit;
        callback(err, commit);
    });
};

var CommitStream = exports.CommitStream = function(repo) {
    if (!(this instanceof CommitStream))
        return new CommitStream(repo);

    Stream.call(this);
    var self = this;

    this.readable = true;
    this.paused = false;
    this.destroyed = false;

    this.repo = repo;

    if (!repo.currentBranch()) {
        throw new Error('current branch is not set');
    }

    var branch = repo.currentBranch();

    this.cached = [];
    this.seq = [branch.object.sha];

    process.nextTick(function() {
        self._nextCommit();
    });
};

util.inherits(CommitStream, Stream);

CommitStream.prototype._nextCommit = function() {
    if (this.paused || !this.readable)
        return;

    var self = this;
    if (self.cached.length) {
        self.emit('data', self.cached.shift());
        self._nextCommit();
        return;
    }

    var sha = self.seq.shift();
    if (!sha) {
        self.emit('end');
        return;
    }

    this.repo.getCommit(sha, function(err, commit) {
        if (!self.paused && self.readable) {
            self.emit('data', commit);
        } else {
            self.cached.push(commit);
        }

        commit.getParents(function(err, parents) {
            if (parents && parents.length) {
                parents.forEach(function(par) {
                    self.seq.push(par.sha);
                });
            }
            self._nextCommit();
        });
    });
};

CommitStream.prototype.pause = function() {
    this.paused = true;
};

CommitStream.prototype.resume = function() {
    this.paused = false;

    this._nextCommit();
};

CommitStream.prototype.setEncoding = function(encoding) {
    'does not supported';
};

CommitStream.prototype.pipe = function() {
    'does not supported';
};

CommitStream.prototype.destroy = function() {
    'does not supported';
};

Repo.prototype.createCommitStream = function() {
    return new CommitStream(this);
};

Repo.prototype.getTree = function(sha, recursive, callback) {
    var self = this;

    if (typeof recursive === 'function') {
        callback = recursive;
        recursive = false;
    }

    dataApi.getTree({
        'user': self.user,
        'repo': self.name,
        'sha': sha,
        'recursive': recursive
    }, function(err, data) {
        // debug(data);
        callback(err, data);
    });
};

// return a snapshot (project tree ) of a commit
Repo.prototype.getSnapshot = function(commit, recursive, callback) {
    this.getTree(commit.tree.sha, recursive, callback);
};


Repo.prototype.getBlob = function(sha, callback) {
    var self = this;

    dataApi.getBlob({
        'user': self.user,
        'repo': self.name,
        'sha': sha
    }, function(err, blob) {
        // debug(blob);
        callback(err, blob);
    });
};
